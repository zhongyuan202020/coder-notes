import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as l}from"./app-CoW43bXR.js";const h={};function t(e,i){return l(),a("div",null,i[0]||(i[0]=[n(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>树。是一个应用非常广泛的数据结构。</p><p>同样的，它也是一个学生看了头疼，程序员遇到了手抖的数据结构。</p><p>主要难在：</p><ol><li>种类繁多：二叉树、二叉搜索树、红黑树、AVL树、B树、B+树、哈夫曼树、字典树、并查集、堆等等。</li><li>专业名词定义繁多：节点、叶子节点、根节点、父节点、子节点、兄弟节点、路径、深度、高度、层等等。</li><li>操作繁多又复杂：遍历、查找、插入、删除、旋转、重构、重建等等。</li><li>递归。不会递归，学不了树。对树的认识也就只停留在了概念上。</li></ol><h2 id="重点" tabindex="-1"><a class="header-anchor" href="#重点"><span>重点</span></a></h2><ol><li>专业名词的记忆。用于学生考试，也用于程序员读题和描述树。</li><li>树的遍历。前序、中序、后序、层次遍历。要深层次的理解递归，很多树相关的算法题，实际都是树的遍历问题。</li><li>树的种类以及特点，应用场景。</li><li>树的操作。比如插入、删除、查找、旋转、重构、重建等等。（了解即可，但是要知道其时间复杂度）</li></ol><p>但是本文的重点不会放在专业名词解释上面，侧重点会在树的种类以及对应的应用场景介绍，最重要的地方会在递归上。</p><p>在本文最后，会附带上树的专有名词和定义，这部分课本内容非常枯燥。如果你正在用这个复习来应对期末考试，可以直接看一下，省得翻书。</p><h2 id="常见的树和应用" tabindex="-1"><a class="header-anchor" href="#常见的树和应用"><span>常见的树和应用</span></a></h2><ol><li>二叉树。</li><li>二叉搜索树。</li><li>平衡二叉搜索树：AVL树，红黑树。</li><li>堆和优先队列。</li><li>线段树。</li><li>字典树。</li><li>并查集。</li><li>B树和B+树。</li></ol><p>不同的树，根据其特点，应用于不同的场景。但是归根结底，几乎都是树的查找问题，也就是遍历问题。树(平衡树)这种结构，得益于其时间复杂度为O(logn)的特性，在计算机科学中，被广泛应用。</p><p>比如：</p><ol><li>数据库索引。MySQL应用的很广泛，在InnoDB中，使用B+树作为索引结构。</li><li>文件系统。Linux文件系统，使用的是树结构。</li><li>游戏开发中的决策树，说大一点，就是人工智能。</li><li>单词自动补全。字典树的应用。</li><li>堆排序。堆的运用。</li><li>范围，区间查询。线段树的应用。</li><li>网络连通，区域标记。并查集应用。</li></ol><p>正因为应用太广泛，所以树的重要性，你懂的。</p><h2 id="递归" tabindex="-1"><a class="header-anchor" href="#递归"><span>递归</span></a></h2><p>谈树，一定离不开递归。</p><h3 id="递归是什么" tabindex="-1"><a class="header-anchor" href="#递归是什么"><span>递归是什么</span></a></h3><p>递归是一种思想，一种解决问题的套路。</p><p>递归的思想是把<strong>原问题分解为多个跟原问题结构一致的子问题，再将子问题，一层一层分解下去，直到每个子问题的规模小到可以被直接解决。然后把这些子问题的解，一层一层合并起来，最终得到原问题的解。</strong></p><p>整个过程，既要有 “递”，也就是分解的过程，也要有 “归”，也就是合并的过程。缺一不可。</p><h3 id="递归举例" tabindex="-1"><a class="header-anchor" href="#递归举例"><span>递归举例</span></a></h3><p>从例子里面感受一下递归。</p><h4 id="阶乘" tabindex="-1"><a class="header-anchor" href="#阶乘"><span>阶乘</span></a></h4><p><strong>问题描述</strong></p><p>一个正整数 n 的阶乘（记作 n!）是所有小于及等于 n 的正整数的积。0 的阶乘定义为 1。请实现一个算法，计算 n 的阶乘。</p><p><strong>解题思路</strong></p><ol><li>递归的终止条件：n=0时，返回1。</li><li>递归的递推公式：n! = n * (n-1)!。</li></ol><p><strong>代码实现</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 函数定义为：传入参数n，返回n的阶乘。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> factorial</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 当n=0时，返回1。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 否则，返回当前值n * （n-1）的阶乘。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // n - 1 的阶乘，就是一个跟原问题相同的子问题。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // n - 1 的阶乘，怎么算？看一下函数定义，函数定义是传入参数n，返回n的阶乘。那么传入n - 1，则返回的就是n - 1的阶乘。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 套入公式，则结果就是下面一行代码</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> factorial</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="斐波那契数列" tabindex="-1"><a class="header-anchor" href="#斐波那契数列"><span>斐波那契数列</span></a></h4><p><strong>问题描述</strong></p><p>数列的每个数字是前两个数字的和，通常以 0 和 1 开始。写出一个方法来计算第 n 项。<br><strong>解题思路</strong></p><ol><li>递归的终止条件：n=0时，返回0。n=1时，返回1。</li><li>递归的递推公式：f(n) = f(n-1) + f(n-2)。</li></ol><p><strong>代码实现</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 函数定义为：传入参数n，返回斐波那契数列的第n项。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fibonacci</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 当n=0时，返回0。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 当n=1时，返回1。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 否则，返回当前值f(n) = f(n-1) + f(n-2)。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // f(n-1) 和 f(n-2) 都是一个跟原问题相同的子问题。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 套入公式，则结果就是下面一行代码</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fibonacci</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fibonacci</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="递归技巧" tabindex="-1"><a class="header-anchor" href="#递归技巧"><span>递归技巧</span></a></h3><ol><li><strong>牢牢的抓住函数的定义（参数，返回值）。</strong></li><li><strong>牢牢的抓住函数的定义（参数，返回值）。</strong></li><li><strong>牢牢的抓住函数的定义（参数，返回值）。</strong></li><li>找到递归的终止条件。<strong>终止条件，其实就是最简单的子问题的解。</strong></li><li>找到递归的递推公式。<strong>递推公式，就是如何将原问题分解为子问题的过程。</strong></li></ol><p>5条技巧，前三条最重要。抓住这几点，递归代码，很好写出来。<strong>千万千万不要用脑子递归，你的脑子压不了几个栈就直接溢出了。</strong></p><p>抓住函数定义，你就不需要大脑压栈了。</p><h2 id="树和递归" tabindex="-1"><a class="header-anchor" href="#树和递归"><span>树和递归</span></a></h2><p>树这种结构，天然支持递归。看图：</p><figure><img src="https://raw.githubusercontent.com/zhongyuan202020/coder-notes-image/main/public/data-structrue/tree/tree.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>上图是一个根为1的树。</li><li>把1这个节点抛开，会有两个子树，分别是2和3。</li><li>把2这个节点抛开，会有两个子树，分别是4和5。</li><li>...</li></ul><p>依次类推，一个树的结构，可以分成当前节点和当前节点的若干个子树。每个子树都是原树的结构一样的子问题。</p><p>一直分解下去，直到分解到叶子节点。不可再分时，叶子节点就是一个最简单问题，一般情况下，也就是最简单子问题的解，也是递归终止条件。</p><h3 id="递归在树中的应用" tabindex="-1"><a class="header-anchor" href="#递归在树中的应用"><span>递归在树中的应用</span></a></h3><p>几乎都在“树的遍历”上。</p><p>无论是前序遍历，中序遍历还是后序遍历，最简洁的代码，都是递归。</p><p>在“树”相关的算法题上，几乎都是围绕遍历问题解开。<br> 比如：</p><ol><li>树的高度。需要从根节点一直遍历到每个叶子结点，找到深的叶子结点即可。</li><li>路径问题。需要从一个节点递归遍历到子节点，同时记录路径信息。</li></ol><h3 id="递归的弊端" tabindex="-1"><a class="header-anchor" href="#递归的弊端"><span>递归的弊端</span></a></h3><p>最大的弊端就是容易造成：栈溢出。</p><p>递归代码的优点就是简洁，思想，套路也比较好理解。但是这种代码在生产环境是严厉禁止的。尤其是递归终止条件非常难以触发的时候。很容易出现栈溢出问题。</p><p>学习递归，主要是学习这种思想，当熟悉这种思想之后，后续在学习算法时，非常有用，比如：动态规划，回溯算法。</p><h2 id="专业名词" tabindex="-1"><a class="header-anchor" href="#专业名词"><span>专业名词</span></a></h2><ol><li>节点。树中的每个元素，都是一个节点。</li><li>叶子节点。没有子节点的节点。</li><li>根节点。树的顶部节点。</li><li>父节点。一个节点的上一级节点。</li><li>子节点。一个节点的下一级节点。</li><li>兄弟节点。同一个父节点的节点。</li><li>路径。从一个节点到另一个节点的路径。</li><li>深度。从根节点到一个节点的路径长度。</li><li>高度。从一个节点到叶子节点的最长路径长度。</li><li>层。从根节点到一个节点的路径长度。</li></ol>`,57)]))}const r=s(h,[["render",t]]),d=JSON.parse('{"path":"/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91.html","title":"树","lang":"zh-CN","frontmatter":{"title":"树","order":6,"category":["数据结构"],"tag":["非线性","树"]},"git":{"createdTime":1748252196000,"updatedTime":1748265568000,"contributors":[{"name":"zhongyuan.zhao","username":"","email":"zhongyuan.zhao@lotusflare.com","commits":4}]},"readingTime":{"minutes":6.78,"words":2034},"filePathRelative":"notes/数据结构/树.md"}');export{r as comp,d as data};
