---
title: 树
order: 6
category:
  - 知识点
tag:
  - 数据结构
  - 树
---
## 前言
树。是一个应用非常广泛的数据结构。

同样的，它也是一个学生看了头疼，程序员遇到了手抖的数据结构。

主要难在：

1. 种类繁多：二叉树、二叉搜索树、红黑树、AVL树、B树、B+树、哈夫曼树、字典树、并查集、堆等等。
2. 定义繁多：满二叉树、完全二叉树、平衡二叉树等等。
3. 专业名词繁多：节点、叶子节点、根节点、父节点、子节点、兄弟节点、路径、深度、高度、层等等。
4. 操作繁多又复杂：遍历、查找、插入、删除、旋转、重构、重建等等。
5. 递归。不会递归，学不了树。对树的认识也就只停留在了概念上。
## 重点
1. 专业名词的记忆。用于学生考试，也用于程序员读题和描述树。
2. 树的定义以及特征。比如满二叉树和完全二叉树有啥区别。
3. 树的遍历。前序、中序、后序、层次遍历。要深层次的理解递归，很多树相关的算法题，实际都是树的遍历问题。
4. 树的种类以及特点，应用场景。
5. 树的操作。比如插入、删除、查找、旋转、重构、重建等等。（了解即可，但是要知道其时间复杂度）

但是本文的重点不会放在名词解释上面，侧重点会在树的种类以及对应的应用场景介绍，最重要的地方会在递归上。

在本文最后，会附带上树的专有名词和定义，这部分课本内容非常枯燥。如果你正在用这个复习来应对期末考试，可以直接看一下，省得翻书。

## 常见的树和应用
1. 二叉树。
2. 二叉搜索树。
3. 平衡二叉树：AVL树，红黑树。
4. 堆和优先队列。
5. 线段树。
6. 字典树。
7. 并查集。
8. B树和B+树。

不同的树，根据其特点，应用于不同的场景。但是归根结底，几乎都是树的查找问题，也就是遍历问题。树(平衡树)这种结构，得益于其时间复杂度为O(logn)的特性，在计算机科学中，被广泛应用。

比如：
1. 数据库索引。MySQL应用的很广泛，在InnoDB中，使用B+树作为索引结构。
2. 文件系统。Linux文件系统，使用的是树结构。
3. 游戏开发中的决策树，说大一点，就是人工智能。
4. 单词自动补全。字典树的应用。
5. 堆排序。堆的运用。
6. 范围，区间查询。线段树的应用。
7. 网络连通，区域标记。并查集应用。

正因为应用太广泛，所以树的重要性，你懂的。

## 递归
谈树，一定离不开递归。
### 递归是什么
递归是一种思想，一种解决问题的套路。

递归的思想是把**原问题分解为多个跟原问题结构一致的子问题，再将子问题，一层一层分解下去，直到每个子问题的规模小到可以被直接解决。然后把这些子问题的解，一层一层合并起来，最终得到原问题的解。**

整个过程，既要有 “递”，也就是分解的过程，也要有 “归”，也就是合并的过程。缺一不可。

### 递归举例
从例子里面感受一下递归。
#### 阶乘
**问题描述** 

一个正整数 n 的阶乘（记作 n!）是所有小于及等于 n 的正整数的积。0 的阶乘定义为 1。请实现一个算法，计算 n 的阶乘。

**解题思路**
1. 递归的终止条件：n=0时，返回1。
2. 递归的递推公式：n! = n * (n-1)!。

**代码实现**
```java
// 函数定义为：传入参数n，返回n的阶乘。
public int factorial(int n) {
    // 当n=0时，返回1。
    if (n == 0) {
        return 1;
    }
    // 否则，返回当前值n * （n-1）的阶乘。
    // n - 1 的阶乘，就是一个跟原问题相同的子问题。
    // n - 1 的阶乘，怎么算？看一下函数定义，函数定义是传入参数n，返回n的阶乘。那么传入n - 1，则返回的就是n - 1的阶乘。
    // 套入公式，则结果就是下面一行代码
    return n * factorial(n - 1);
}
```
#### 斐波那契数列
**问题描述**

数列的每个数字是前两个数字的和，通常以 0 和 1 开始。写出一个方法来计算第 n 项。
**解题思路**

1. 递归的终止条件：n=0时，返回0。n=1时，返回1。
2. 递归的递推公式：f(n) = f(n-1) + f(n-2)。

**代码实现**
```java
// 函数定义为：传入参数n，返回斐波那契数列的第n项。
public int fibonacci(int n) {
    // 当n=0时，返回0。
    if (n == 0) {
        return 0;
    }
    // 当n=1时，返回1。
    if (n == 1) {
        return 1;
    }
    // 否则，返回当前值f(n) = f(n-1) + f(n-2)。
    // f(n-1) 和 f(n-2) 都是一个跟原问题相同的子问题。
    // 套入公式，则结果就是下面一行代码
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

### 递归技巧
1. **牢牢的抓住函数的定义（参数，返回值）。**
2. **牢牢的抓住函数的定义（参数，返回值）。**
3. **牢牢的抓住函数的定义（参数，返回值）。**
4. 找到递归的终止条件。**终止条件，其实就是最简单的子问题的解。**
5. 找到递归的递推公式。**递推公式，就是如何将原问题分解为子问题的过程。**

5条技巧，前三条最重要。抓住这几点，递归代码，很好写出来。**千万千万不要用脑子递归，你的脑子压不了几个栈就直接溢出了。**

抓住函数定义，你就不需要大脑压栈了。

## 树和递归
树这种结构，天然支持递归。看图：
![图1](https://raw.githubusercontent.com/zhongyuan202020/coder-notes-image/main/public/data-structrue/tree/tree.png)

- 上图是一个根为1的树。
- 把1这个节点抛开，会有两个子树，分别是2和3。
- 把2这个节点抛开，会有两个子树，分别是4和5。
- ...

依次类推，一个树的结构，可以分成当前节点和当前节点的若干个子树。每个子树都是原树的结构一样的子问题。

一直分解下去，直到分解到叶子节点。不可再分时，叶子节点就是一个最简单问题，一般情况下，也就是最简单子问题的解，也是递归终止条件。

### 递归在树中的应用
几乎都在“树的遍历”上。

无论是前序遍历，中序遍历还是后序遍历，最简洁的代码，都是递归。

在“树”相关的算法题上，几乎都是围绕遍历问题解开。
比如：
1. 树的高度。需要从根节点一直遍历到每个叶子结点，找到深的叶子结点即可。
2. 路径问题。需要从一个节点递归遍历到子节点，同时记录路径信息。

### 递归的弊端
最大的弊端就是容易造成：栈溢出。

递归代码的优点就是简洁，思想，套路也比较好理解。但是这种代码在生产环境是严厉禁止的。尤其是递归终止条件非常难以触发的时候。很容易出现栈溢出问题。

学习递归，主要是学习这种思想，当熟悉这种思想之后，后续在学习算法时，非常有用，比如：动态规划，回溯算法。

## 专业名词
1. 节点。树中的每个元素，都是一个节点。
2. 叶子节点。没有子节点的节点。
3. 根节点。树的顶部节点。
4. 父节点。一个节点的上一级节点。
5. 子节点。一个节点的下一级节点。
6. 兄弟节点。同一个父节点的节点。
7. 路径。从一个节点到另一个节点的路径。
8. 深度。从根节点到一个节点的路径长度。
9. 高度。从一个节点到叶子节点的最长路径长度。
10. 层。从根节点到一个节点的路径长度。

## 树的定义和特征
1. 树是一种非线性的数据结构。
2. 树的定义：树是由n（n>=0）个有限节点组成一个具有层次关系的集合。

满二叉树：
1. 满二叉树是一种特殊的二叉树。
2. 满二叉树的定义：每个节点都有两个子节点，并且所有的叶子节点都在同一层上。
3. 满二叉树的特征：叶子节点都在同一层上，并且每个节点都有两个子节点。
4. 满二叉树的性质：
   1. 第i层的节点数为2^(i-1)。
   2. 深度为k的满二叉树，节点数为2^k-1。
   3. 满二叉树的叶子节点数为2^(k-1)。

完全二叉树：
1. 完全二叉树的定义：除了最后一层，其他层的节点都是满的，最后一层的节点都靠左排列。
2. 性质：
   1. 叶子节点只可能出现在最后两层。
   2. 最后一层的叶子节点都靠左排列。
   3. 满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树。
   4. 完全二叉树的节点数，大于等于满二叉树的节点数。

平衡二叉树：
1. 平衡二叉树的定义：每个节点的左右子树的高度差不超过1。
2. 平衡二叉树的性质：
   1. 第i层的节点数为2^(i-1)。
   2. 深度为k的平衡二叉树，节点数为2^k-1。
   3. 平衡二叉树的叶子节点数为2^(k-1)。